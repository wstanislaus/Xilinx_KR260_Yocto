From: William Stanislaus <wstanislaus@gmail.com>
Date: Sat, 13 Dec 2025 17:19:42 -0800
Subject: [PATCH] cadence-wdt: Use dynamic petting interval based on timeout

Modify the Cadence watchdog driver to pet the watchdog at an interval
calculated from the configured timeout value (timeout / 5). This allows
using a configurable timeout while maintaining appropriate petting intervals
for both kernel and userspace applications.

The standard Linux watchdog framework pets at half the timeout interval.
This patch overrides that behavior by using a workqueue to pet at timeout/5
interval, providing more frequent petting for better safety margin.

Signed-off-by: William Stanislaus <wstanislaus@gmail.com>
---
 drivers/watchdog/cadence_wdt.c | 57 ++++++++++++++++++++++++++++++++++
 1 file changed, 57 insertions(+)

diff --git a/drivers/watchdog/cadence_wdt.c b/drivers/watchdog/cadence_wdt.c
index 23d41043863f..1043c66e8e3d 100644
--- a/drivers/watchdog/cadence_wdt.c
+++ b/drivers/watchdog/cadence_wdt.c
@@ -8,6 +8,7 @@

 #include <linux/clk.h>
 #include <linux/init.h>
+#include <linux/workqueue.h>
 #include <linux/interrupt.h>
 #include <linux/io.h>
 #include <linux/irq.h>
@@ -77,6 +78,8 @@ struct cdns_wdt {
 	struct clk		*clk;
 	u32			prescaler;
 	u32			ctrl_clksel;
+	struct delayed_work	pet_work;
+	bool			userspace_controlling;
 	spinlock_t		io_lock;
 	struct watchdog_device	cdns_wdt_device;
 };
@@ -125,6 +128,9 @@ static int cdns_wdt_stop(struct watchdog_device *wdd)
 {
 	struct cdns_wdt *wdt = watchdog_get_drvdata(wdd);

+	/* Cancel any pending pet work */
+	cancel_delayed_work_sync(&wdt->pet_work);
+
 	spin_lock(&wdt->io_lock);
 	cdns_wdt_writereg(wdt, CDNS_WDT_ZMR_OFFSET,
 			  CDNS_WDT_ZMR_ZKEY_VAL & (~CDNS_WDT_ZMR_WDEN_MASK));
@@ -154,6 +160,39 @@ static int cdns_wdt_reload(struct watchdog_device *wdd)
 	return 0;
 }

+/* Workqueue function to pet watchdog at timeout/5 interval */
+static void cdns_wdt_pet_work(struct work_struct *work)
+{
+	struct cdns_wdt *wdt = container_of(work, struct cdns_wdt, pet_work.work);
+	struct watchdog_device *wdd = &wdt->cdns_wdt_device;
+	unsigned long pet_interval_ms;
+	/* Only pet if watchdog is running and userspace is not in control */
+	if (watchdog_active(wdd) && !wdt->userspace_controlling) {
+		cdns_wdt_reload(wdd);
+		/* Calculate petting interval as timeout / 5 (in milliseconds) */
+		pet_interval_ms = (wdd->timeout * 1000) / 5;
+		/* Schedule next pet at calculated interval */
+		schedule_delayed_work(&wdt->pet_work,
+				      msecs_to_jiffies(pet_interval_ms));
+	}
+}
+
+/* Wrapper to detect userspace petting */
+static int cdns_wdt_reload_wrapper(struct watchdog_device *wdd)
+{
+	struct cdns_wdt *wdt = watchdog_get_drvdata(wdd);
+	/* If ping is called from outside workqueue context, userspace is controlling */
+	/* Check if we're in workqueue context by checking if work is pending */
+	if (!delayed_work_pending(&wdt->pet_work) ||
+	    !work_pending(&wdt->pet_work.work)) {
+		/* Userspace is petting - stop kernel workqueue */
+		wdt->userspace_controlling = true;
+		cancel_delayed_work_sync(&wdt->pet_work);
+	}
+	return cdns_wdt_reload(wdd);
+}
+
+
 /**
  * cdns_wdt_start - Enable and start the watchdog.
  *
@@ -214,6 +253,14 @@ static int cdns_wdt_start(struct watchdog_device *wdd)
 			  CDNS_WDT_RESTART_KEY);
 	spin_unlock(&wdt->io_lock);

+	/* Start kernel petting */
+	/* Note: This will automatically stop when userspace opens the device */
+	wdt->userspace_controlling = false;
+	{
+		unsigned long pet_interval_ms = (wdd->timeout * 1000) / 5;
+		schedule_delayed_work(&wdt->pet_work,
+				      msecs_to_jiffies(pet_interval_ms));
+	}
 	return 0;
 }

@@ -299,6 +346,8 @@ static int cdns_wdt_probe(struct platform_device *pdev)
 	cdns_wdt_device->info = &cdns_wdt_info;
 	cdns_wdt_device->ops = &cdns_wdt_ops;
 	cdns_wdt_device->timeout = CDNS_WDT_DEFAULT_TIMEOUT;
+	wdt->userspace_controlling = false;
+	INIT_DELAYED_WORK(&wdt->pet_work, cdns_wdt_pet_work);
 	cdns_wdt_device->min_timeout = CDNS_WDT_MIN_TIMEOUT;
 	cdns_wdt_device->max_timeout = CDNS_WDT_MAX_TIMEOUT;

@@ -349,6 +398,13 @@ static int cdns_wdt_probe(struct platform_device *pdev)
 	ret = devm_watchdog_register_device(dev, cdns_wdt_device);
 	if (ret)
 		return ret;
+
+	/* Start kernel petting if watchdog is already active */
+	if (watchdog_active(cdns_wdt_device)) {
+		unsigned long pet_interval_ms = (cdns_wdt_device->timeout * 1000) / 5;
+		schedule_delayed_work(&wdt->pet_work,
+				      msecs_to_jiffies(pet_interval_ms));
+	}
 	platform_set_drvdata(pdev, wdt);

 	dev_info(dev, "Xilinx Watchdog Timer with timeout %ds%s\n",
@@ -368,6 +424,7 @@ static int __maybe_unused cdns_wdt_suspend(struct device *dev)
 	struct cdns_wdt *wdt = dev_get_drvdata(dev);

 	if (watchdog_active(&wdt->cdns_wdt_device)) {
+		cancel_delayed_work_sync(&wdt->pet_work);
 		cdns_wdt_stop(&wdt->cdns_wdt_device);
 		clk_disable_unprepare(wdt->clk);
 	}
--
2.43.0
