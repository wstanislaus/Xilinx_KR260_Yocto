#!/bin/sh

export PATH=/sbin:/usr/sbin:/bin:/usr/bin

# Message logging function - logs to kernel log and console
msg() {
    local message="$*"
    # Log to kernel message buffer (visible in dmesg)
    echo "searche2fs: $message" > /dev/kmsg 2>&1 || true
    # Also print to console
    echo "$message" > /dev/console 2>&1 || true
}

BOOTARG_IP=""
BOOTARG_SERVER=""
BOOTARG_GW=""
BOOTARG_NETMASK=""
BOOTARG_IFACE=""
BOOTARG_AUTOCONF=""
STATIC_IP_CONFIGURED=0

parse_bootargs_ip() {
	local cmdline arg ip_param oldifs
	cmdline=$(cat /proc/cmdline 2>/dev/null)
	for arg in $cmdline; do
		case "$arg" in
			ip=*)
				ip_param=${arg#ip=}
				break
				;;
		esac
	done
	[ -z "$ip_param" ] && return
	oldifs=$IFS
	IFS=':'
	set -- $ip_param
	IFS=$oldifs
	BOOTARG_IP=$1
	BOOTARG_SERVER=$2
	BOOTARG_GW=$3
	BOOTARG_NETMASK=$4
	BOOTARG_HOSTNAME=$5
	BOOTARG_IFACE=$6
	BOOTARG_AUTOCONF=$7
	[ -z "$BOOTARG_IFACE" ] && BOOTARG_IFACE="eth0"
}

configure_static_ip_from_bootargs() {
	local dev mask
	[ -n "$BOOTARG_IP" ] || return
	[ $STATIC_IP_CONFIGURED -eq 1 ] && return
	dev=${BOOTARG_IFACE:-eth0}
	[ -d "/sys/class/net/$dev" ] || return
	mask=${BOOTARG_NETMASK:-255.255.255.0}
	if ! ifconfig $dev 2>/dev/null | grep -q "inet "; then
		msg "Configuring $dev with static IP $BOOTARG_IP/$mask from bootargs"
		if ! ifconfig $dev $BOOTARG_IP netmask $mask up 2>/dev/null; then
			msg "Warning: Failed to configure static IP on $dev via ifconfig"
			return
		fi
	fi
	if [ -n "$BOOTARG_GW" ]; then
		if ! route -n 2>/dev/null | grep -q "^0.0.0.0\|^default"; then
			msg "Adding default route via $BOOTARG_GW (from bootargs)"
			route add default gw $BOOTARG_GW dev $dev 2>/dev/null || \
				ip route add default via $BOOTARG_GW dev $dev 2>/dev/null || \
				msg "Warning: Failed to add default route via $BOOTARG_GW"
		fi
	fi
	STATIC_IP_CONFIGURED=1
}

parse_bootargs_ip

searche2fs_run() {

	# Check boottype parameter (can be from bootparam_boottype or parsed from bootargs)
	boottype="${bootparam_boottype}"
	if [ -z "$boottype" ]; then
		# Try to parse from /proc/cmdline
		boottype=$(cat /proc/cmdline 2>/dev/null | grep -o 'boottype=[^ ]*' | cut -d= -f2 || echo "")
	fi

	echo "=== searche2fs: boottype='$boottype' ===" > /dev/kmsg 2>&1 || echo "=== boottype='$boottype' ==="

	if [ "$boottype" = "nfs" ]; then

		# boottype=nfs nfsserver=172.20.1.1 nfspath=/nfsroot
		# ip=172.20.1.2::172.20.1.1:255.255.255.0:Xilinx-KR260:eth0:bootp

		mount_folder=/rootfs
		mount_attempts=5
		mount_cnt=1
		mount_success=0

		# Get NFS server and path from boot parameters
		nfsserver="${bootparam_nfsserver}"
		nfspath="${bootparam_nfspath}"

		if [ -z "$nfsserver" ]; then
			nfsserver=$(cat /proc/cmdline 2>/dev/null | grep -o 'nfsserver=[^ ]*' | cut -d= -f2 || echo "")
		fi
		if [ -z "$nfsserver" ] && [ -n "$BOOTARG_SERVER" ]; then
			nfsserver=$BOOTARG_SERVER
		fi
		if [ -z "$nfspath" ]; then
			nfspath=$(cat /proc/cmdline 2>/dev/null | grep -o 'nfspath=[^ ]*' | cut -d= -f2 || echo "")
		fi

		if [ -z "$nfsserver" ] || [ -z "$nfspath" ]; then
			msg "ERROR: NFS server or path not specified in boot parameters"
			msg "  nfsserver: $nfsserver"
			msg "  nfspath: $nfspath"
			return 1
		fi

		msg "NFS boot detected:"
		msg "  Server: $nfsserver"
		msg "  Path: $nfspath"
		echo "=== searche2fs: NFS boot detected, server=$nfsserver, path=$nfspath ===" > /dev/kmsg 2>&1 || true

		# Wait for network interface to be ready
		# The ethernet driver may be deferred waiting for clock controller
		msg "Waiting for network interface to be ready..."

		# Wait for eth0 to appear in /sys/class/net (more reliable than ifconfig)
		interface_ready=0
		wait_count=0
		max_wait=45  # Wait up to 45 seconds (increased from 30)

		while [ $wait_count -lt $max_wait ]; do
			# Check if eth0 exists in /sys/class/net
			if [ -d /sys/class/net/eth0 ]; then
				msg "eth0 interface found in /sys/class/net"
				# Check if it's up
				if [ -f /sys/class/net/eth0/operstate ]; then
					operstate=$(cat /sys/class/net/eth0/operstate 2>/dev/null || echo "down")
					msg "eth0 operstate: $operstate"
					if [ "$operstate" = "up" ] || [ "$operstate" = "unknown" ]; then
						interface_ready=1
						break
					fi
				fi
				# Try to bring it up if it exists but is down
				ifconfig eth0 up 2>/dev/null || ip link set eth0 up 2>/dev/null || true
				sleep 1
			fi

			# Also check ifconfig as fallback
			if ifconfig eth0 >/dev/null 2>&1; then
				msg "eth0 found via ifconfig"
				interface_ready=1
				break
			fi

			# Check dmesg for ethernet-related messages
			if [ $((wait_count % 10)) -eq 0 ] && [ $wait_count -gt 0 ]; then
				msg "Checking kernel messages for ethernet..."
				dmesg | tail -20 | grep -i "eth\|gem\|ethernet\|ff0e" || true
			fi

			wait_count=$((wait_count + 1))
			if [ $((wait_count % 5)) -eq 0 ]; then
				msg "Still waiting for eth0... ($wait_count/$max_wait seconds)"
				# List available interfaces for debugging
				msg "Available interfaces: $(ls /sys/class/net/ 2>/dev/null | tr '\n' ' ' || echo 'none')"
				# Check if ethernet device exists in /sys/bus/platform/devices
				if [ -d /sys/bus/platform/devices ]; then
					eth_devices=$(ls /sys/bus/platform/devices/ 2>/dev/null | grep -i "ff0e\|ethernet\|gem" || echo "none")
					if [ "$eth_devices" != "none" ]; then
						msg "Ethernet platform devices found: $eth_devices"
						# Check driver status
						for dev in $eth_devices; do
							if [ -e /sys/bus/platform/devices/$dev/driver ]; then
								driver_name=$(readlink /sys/bus/platform/devices/$dev/driver 2>/dev/null | xargs basename || echo "unknown")
								msg "  $dev driver: $driver_name"
							else
								msg "  $dev: no driver bound"
							fi
						done
					fi
				fi
			fi
			sleep 1
		done

		if [ $interface_ready -eq 0 ]; then
			msg "Warning: eth0 not ready after $max_wait seconds, continuing anyway..."
			msg "Available network interfaces: $(ls /sys/class/net/ 2>/dev/null | tr '\n' ' ' || echo 'none')"
			# Show detailed debugging info
			msg "Platform devices: $(ls /sys/bus/platform/devices/ 2>/dev/null | grep -i gem || echo 'none')"
			msg "Recent kernel messages about ethernet:"
			dmesg | tail -30 | grep -i "eth\|gem\|ethernet\|ff0e\|deferred" || msg "  (no relevant messages)"
		else
			msg "Network interface eth0 is ready"
			configure_static_ip_from_bootargs
			# Show interface status
			ifconfig eth0 2>/dev/null | head -3 || ip addr show eth0 2>/dev/null | head -5 || true
		fi

		while [ $mount_cnt -le $mount_attempts ]
		do
			msg "Attempt to mount NFS ($mount_cnt/$mount_attempts): "
			msg "  Server: $nfsserver"
			msg "  Path: $nfspath"

			# Show network status
			ifconfig eth0 2>/dev/null | head -2 || msg "  Warning: Cannot get eth0 status"

			# Add default route if needed
			if ! route | grep -q default; then
				msg "  Adding default route via $nfsserver"
				route add default gw $nfsserver 2>/dev/null || true
			fi

			# Ping server to check connectivity
			msg "  Checking connectivity to $nfsserver..."
			if ping -c 1 -W 3 $nfsserver >/dev/null 2>&1; then
				msg "  Server is reachable"
			else
				msg "  Warning: Cannot ping server, trying mount anyway"
			fi

			# Create mount point
			mkdir -p $mount_folder

			# Mount attempt (set server ip and shared folder)
			msg "  Attempting NFS mount..."
			echo "=== searche2fs: Mount attempt $mount_cnt: mount -t nfs $nfsserver:$nfspath $mount_folder ===" > /dev/kmsg 2>&1 || true
			# Capture mount error output for debugging
			mount_output=$(mount -t nfs -o nolock,vers=3,timeo=10 $nfsserver:$nfspath $mount_folder 2>&1)
			mount_exit=$?
			if [ $mount_exit -eq 0 ]; then
				msg "NFS rootfs successfully mounted at $mount_folder"
				echo "=== searche2fs: NFS mount SUCCESS ===" > /dev/kmsg 2>&1 || true
				mount_success=1
				break
			else
				msg "Mount attempt $mount_cnt failed, retrying in 2 seconds..."
				msg "Mount error: $mount_output"
				echo "=== searche2fs: Mount attempt $mount_cnt FAILED: $mount_output ===" > /dev/kmsg 2>&1 || true
			fi
			true $((mount_cnt=mount_cnt+1))
			sleep 2
		done

		if [ $mount_success -eq 1 ]; then
			# Verify the mount is actually accessible
			if [ ! -d "$mount_folder" ]; then
				msg "ERROR: Mount point $mount_folder does not exist"
				return 1
			fi

			# Set and export ROOTFS_DIR so the initramfs framework knows where the root is mounted
			export ROOTFS_DIR=${mount_folder}
			msg "ROOTFS_DIR exported as: $ROOTFS_DIR"

			# Verify mounted filesystem has essential directories
			if [ ! -d $ROOTFS_DIR/dev ]; then
				msg "Warning: There's no '/dev' on NFS mount"
			fi

			# Check for init binary (required for switch_root)
			if [ ! -f $ROOTFS_DIR/sbin/init ] && [ ! -f $ROOTFS_DIR/init ] && [ ! -f $ROOTFS_DIR/bin/init ]; then
				msg "ERROR: No init binary found in mounted rootfs"
				msg "  Checked: $ROOTFS_DIR/sbin/init, $ROOTFS_DIR/init, $ROOTFS_DIR/bin/init"
				msg "  Listing $ROOTFS_DIR:"
				ls -la $ROOTFS_DIR/ | head -10
				return 1
			fi

			# Use check_init function from initramfs framework
			if check_init $ROOTFS_DIR; then
				msg "Root filesystem verified successfully"
			else
				msg "Warning: check_init reported issues, but continuing..."
			fi

			msg "NFS rootfs ready for switch_root"
			echo "=== searche2fs: NFS mount successful, ROOTFS_DIR=$ROOTFS_DIR ===" > /dev/kmsg 2>&1 || true
			return 0
		else
			msg "ERROR: Failed to mount NFS rootfs after $mount_attempts attempts"
			msg "  Check network connectivity and NFS server configuration"
			echo "=== searche2fs: NFS mount FAILED ===" > /dev/kmsg 2>&1 || true
			return 1
		fi

	else

		if [ -n "$bootparam_launch_ramdisk_init" ]; then
			msg "launch_ramdisk_init is set, Launching ramdisk init"
			# Stay in initramfs, don't set ROOTFS_DIR
			return 0
		fi

		# Try to mount local storage as root
		if [ -z "$ROOTFS_DIR" ]; then
			ROOTFS_DIR=/rootfs
		fi
		export ROOTFS_DIR

		if [ -z "${bootparam_ext2}" ] && [ -z "${bootparam_ext3}" ] && [ -z "${bootparam_ext4}" ]; then
			boot_devices=""
			block_devices=""
			sleep 2
			block_devices=$(ls /sys/block/ | grep -e "sd[a-z]\{1,\}$" -e "mmcblk[0-9]\{1,\}$")
			for block_device in $block_devices; do
				boot_devices=$(blkid /dev/${block_device}* | grep "TYPE=\"ext" | cut -d: -f 1)
				for boot_device in $boot_devices; do
					if [ -e ${boot_device} ]; then
						boot_device_type="$(blkid ${boot_device} | grep -o 'TYPE=.*' | cut -d\" -f 2)"
						mkdir -p "$ROOTFS_DIR"
						check_fsck "$boot_device" "$boot_device_type"
						if mount -t $boot_device_type $boot_device $ROOTFS_DIR 2>&1; then
							if [ ! -d $ROOTFS_DIR/dev ]; then
								umount $ROOTFS_DIR
								msg "There's no '/dev' on $boot_device_type(${boot_device}) partition."
							else
								if ! check_init $ROOTFS_DIR; then
									msg "Warning: check_init failed for $ROOTFS_DIR"
									# Don't unmount, let finish script handle it
								fi
								msg "Local rootfs mounted at $ROOTFS_DIR"
								echo "=== searche2fs: Local rootfs mounted at $ROOTFS_DIR from $boot_device ===" > /dev/kmsg 2>&1 || true
								
								# Automatically resize root partition to maximum size for eMMC/SD card
								# Check if this is an eMMC or SD card device (not NFS)
								if echo "$boot_device" | grep -qE "(mmcblk|sd[a-z])"; then
									msg "Detected local storage device ($boot_device), attempting to resize root partition to maximum size..."
									echo "=== searche2fs: Detected local storage ($boot_device), starting resize ===" > /dev/kmsg 2>&1 || true
									if command -v resize-part >/dev/null 2>&1 && command -v parted >/dev/null 2>&1 && command -v resize2fs >/dev/null 2>&1; then
										# Extract device and partition number for manual resize if needed
										if echo "$boot_device" | grep -qE "/dev/mmcblk[0-9]+p[0-9]+"; then
											# Format: /dev/mmcblk0p2 -> /dev/mmcblk0 and 2
											ROOT_DEV=$(echo "$boot_device" | sed -E 's/p[0-9]+$//')
											PART_NUM=$(echo "$boot_device" | sed -E 's/.*p([0-9]+)$/\1/')
										elif echo "$boot_device" | grep -qE "/dev/sd[a-z][0-9]+"; then
											# Format: /dev/sda2 -> /dev/sda and 2
											ROOT_DEV=$(echo "$boot_device" | sed -E 's/[0-9]+$//')
											PART_NUM=$(echo "$boot_device" | sed -E 's/.*([0-9]+)$/\1/')
										else
											msg "Warning: Unable to parse device name: $boot_device"
											ROOT_DEV=""
											PART_NUM=""
										fi
										
										msg "Device: $ROOT_DEV, Partition: $PART_NUM"
										echo "=== searche2fs: Resize - Device=$ROOT_DEV, Partition=$PART_NUM ===" > /dev/kmsg 2>&1 || true
										
										# Validate we have valid device and partition number
										if [ -z "$ROOT_DEV" ] || [ -z "$PART_NUM" ]; then
											msg "Error: Could not extract device or partition number from $boot_device"
											echo "=== searche2fs: ERROR - Could not parse device/partition from $boot_device ===" > /dev/kmsg 2>&1 || true
											msg "Trying fallback method with resize-part script..."
											# Fallback to resize-part script
											if resize-part "$boot_device" 2>&1; then
												msg "Fallback resize-part succeeded"
											else
												msg "Warning: Fallback resize-part also failed"
											fi
											# Try to remount and continue
											if mount -t $boot_device_type $boot_device $ROOTFS_DIR 2>&1; then
												msg "Rootfs remounted after fallback resize attempt"
											fi
											return 0
										fi
										
										# Verify device exists
										if [ ! -b "$ROOT_DEV" ]; then
											msg "Error: Device $ROOT_DEV does not exist"
											return 0
										fi
										
										# Get initial partition size for verification
										INITIAL_SIZE=$(parted -s "$ROOT_DEV" unit B print 2>/dev/null | grep "^[[:space:]]*$PART_NUM" | awk '{print $4}' | sed 's/B$//' 2>/dev/null || echo "")
										if [ -n "$INITIAL_SIZE" ]; then
											msg "Initial partition size: $INITIAL_SIZE bytes"
											echo "=== searche2fs: Initial partition size: $INITIAL_SIZE bytes ===" > /dev/kmsg 2>&1 || true
										fi
										
										# Unmount temporarily to safely resize partition table
										msg "Unmounting rootfs temporarily to resize partition..."
										echo "=== searche2fs: Unmounting $ROOTFS_DIR for resize ===" > /dev/kmsg 2>&1 || true
										if ! umount "$ROOTFS_DIR" 2>&1; then
											msg "Warning: Failed to unmount for resize, trying to resize anyway..."
										fi
										
										# Wait a moment for unmount to complete
										sleep 1
										
										# Resize partition table first using parted directly
										if [ -n "$ROOT_DEV" ] && [ -n "$PART_NUM" ]; then
											msg "Resizing partition table: parted $ROOT_DEV resizepart $PART_NUM 100%"
											echo "=== searche2fs: Executing: parted -s $ROOT_DEV resizepart $PART_NUM 100% ===" > /dev/kmsg 2>&1 || true
											RESIZE_OUTPUT=$(parted -s "$ROOT_DEV" resizepart "$PART_NUM" 100% 2>&1)
											RESIZE_EXIT=$?
											echo "=== searche2fs: parted exit code: $RESIZE_EXIT ===" > /dev/kmsg 2>&1 || true
											if [ $RESIZE_EXIT -eq 0 ]; then
												msg "Partition table resized successfully"
												echo "=== searche2fs: Partition table resize SUCCESS ===" > /dev/kmsg 2>&1 || true
												# Verify the resize
												FINAL_SIZE=$(parted -s "$ROOT_DEV" unit B print 2>/dev/null | grep "^[[:space:]]*$PART_NUM" | awk '{print $4}' | sed 's/B$//' 2>/dev/null || echo "")
												if [ -n "$FINAL_SIZE" ] && [ -n "$INITIAL_SIZE" ]; then
													msg "Final partition size: $FINAL_SIZE bytes"
													echo "=== searche2fs: Final partition size: $FINAL_SIZE bytes ===" > /dev/kmsg 2>&1 || true
													if [ "$FINAL_SIZE" != "$INITIAL_SIZE" ]; then
														msg "Partition size changed from $INITIAL_SIZE to $FINAL_SIZE bytes"
														echo "=== searche2fs: Partition expanded from $INITIAL_SIZE to $FINAL_SIZE bytes ===" > /dev/kmsg 2>&1 || true
													else
														msg "Warning: Partition size did not change"
														echo "=== searche2fs: WARNING - Partition size unchanged ===" > /dev/kmsg 2>&1 || true
													fi
												fi
											else
												msg "Warning: Failed to resize partition table (exit code: $RESIZE_EXIT)"
												msg "Parted output: $RESIZE_OUTPUT"
												echo "=== searche2fs: ERROR - Partition resize FAILED (exit $RESIZE_EXIT): $RESIZE_OUTPUT ===" > /dev/kmsg 2>&1 || true
											fi
										fi
										
										# Trigger kernel to re-read partition table
										msg "Triggering kernel to re-read partition table..."
										if [ -f /sys/block/${ROOT_DEV##/dev/}/force_rescan ]; then
											echo 1 > /sys/block/${ROOT_DEV##/dev/}/force_rescan 2>/dev/null || true
										fi
										# Try partprobe if available, otherwise skip (kernel should auto-detect)
										if command -v partprobe >/dev/null 2>&1; then
											partprobe "$ROOT_DEV" 2>/dev/null || true
										fi
										sleep 1
										
										# Resize filesystem using resize2fs
										msg "Resizing filesystem: resize2fs $boot_device"
										echo "=== searche2fs: Executing: resize2fs $boot_device ===" > /dev/kmsg 2>&1 || true
										RESIZE2FS_OUTPUT=$(resize2fs "$boot_device" 2>&1)
										RESIZE2FS_EXIT=$?
										echo "=== searche2fs: resize2fs exit code: $RESIZE2FS_EXIT ===" > /dev/kmsg 2>&1 || true
										if [ $RESIZE2FS_EXIT -eq 0 ]; then
											msg "Filesystem resized successfully"
											echo "=== searche2fs: Filesystem resize SUCCESS ===" > /dev/kmsg 2>&1 || true
										else
											msg "Warning: Failed to resize filesystem (exit code: $RESIZE2FS_EXIT)"
											msg "resize2fs output: $RESIZE2FS_OUTPUT"
											echo "=== searche2fs: ERROR - Filesystem resize FAILED (exit $RESIZE2FS_EXIT): $RESIZE2FS_OUTPUT ===" > /dev/kmsg 2>&1 || true
										fi
										
										# Remount the rootfs
										msg "Remounting rootfs after resize..."
										echo "=== searche2fs: Remounting $boot_device to $ROOTFS_DIR ===" > /dev/kmsg 2>&1 || true
										if mount -t $boot_device_type $boot_device $ROOTFS_DIR 2>&1; then
											msg "Rootfs remounted successfully after resize"
											echo "=== searche2fs: Remount SUCCESS - Rootfs ready ===" > /dev/kmsg 2>&1 || true
										else
											msg "ERROR: Failed to remount rootfs after resize"
											echo "=== searche2fs: ERROR - Remount FAILED ===" > /dev/kmsg 2>&1 || true
											return 1
										fi
									else
										msg "Warning: resize tools not available (resize-part, parted, or resize2fs missing), skipping partition resize"
									fi
								fi
								
								return 0
							fi
						else
							msg "Failed to mount selected root filesystem ($boot_device)"
						fi
					fi
				done
			done
			msg "No suitable root filesystem found on local storage"
		fi
	fi

	# If we get here and ROOTFS_DIR is not set, something went wrong
	if [ -z "$ROOTFS_DIR" ]; then
		msg "ERROR: ROOTFS_DIR is not set and no root filesystem was mounted"
		return 1
	fi

	return 0
}
